#### 171. Як захистити SharedArrayBuffer від запису з різних worker_threads?

Щоб захистити `SharedArrayBuffer` від одночасного запису з різних `worker_threads`, можна скористатися механізмами синхронізації. Ось кілька підходів, які ви можете використати:

1. **Атомарні операції**: Використовуйте атомарні операції з об'єктом `Atomics`, що дозволяє виконувати операції безпечно без блокування. Приклади таких операцій: `Atomics.add()`, `Atomics.sub()`, `Atomics.and()`, `Atomics.or()`, та інші.

2. **Мьютекси**: Реалізуйте мьютекс (ключ блокування), щоб мати контроль над доступом до спільного ресурсу. Це можна зробити, наприклад, через Atomics з флагом, що визначає доступність ресурсу.

3. **Семафори**: Ви можете використовувати логіку семафорів для більш складного управління доступом, дозволяючи декільком потокам доступ, але обмежуючи кількість одночасних доступів.

4. **Умовні змінні (Condition Variables)**: Часом корисно мати можливість чекати на певну умову перед тим як продовжити роботу. Це може бути реалізоване шляхом співпраці з атомарними операціями та циклічного опитування із затримкою.

Приклад використання атомарних операцій:

```javascript
const sab = new SharedArrayBuffer(1024);
const ta = new Int32Array(sab);

function workerTask() {
  for (let i = 0; i < 1000; i++) {
    Atomics.add(ta, 0, 1); // атомарно додає 1 до першого індексу
  }
}
```

Цей приклад показує, як безпечно збільшувати значення в `SharedArrayBuffer` з декількох потоків без гонок даних. Атомарні операції гарантують, що зміни будуть коректно відслідковані у всіх потоках.

| Back | Forward |
|---|---|
| [Що можна робити за допомогою node:vm?](/ua/strong-middle/questions-for-a-systems-programmer/what-can-be-done-with-nodevm.md)  | [Доведіть, що будь-який модуль у Node.js при завантаженні огортається у функцію і створює замикання?](/ua/strong-middle/questions-for-a-systems-programmer/is-every-module-in-nodejs-wrapped-into-a-function-and-creates-closures-when-loaded.md) |