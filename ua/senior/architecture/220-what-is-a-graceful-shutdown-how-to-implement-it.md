#### 220. Що таке graceful shutdown? Як його імплементувати?

"Graceful shutdown" (лагідне завершення) — це процес акуратного зупинення програми чи сервісу, що дозволяє завершити поточні операції та очищення ресурсів перед остаточним вимкненням. Це важливо, щоб уникнути втрачених даних, корупції файлів або некоректних станів системи. 

### Основні кроки для імплементації graceful shutdown:

1. **Відстеження сигналів**: Програма має вміти отримувати та обробляти сигнали системи, наприклад, SIGTERM чи SIGINT. Це дає змогу сервісу усвідомити, що необхідно коректно завершити роботу.

2. **Припинення приймання нових запитів**: Сервер має зупинити обробку нових запитів, але продовжити обробляти ті, що вже в роботі. Наприклад, веб-сервер може закривати сокети нового підключення або знімати з балансувача навантаження.

3. **Завершення обробки поточних запитів**: Завершіть обробку тих запитів, які вже розпочались. Якщо є можливість, намагайтеся встановити межу по часу, щоб уникнути надто довгого завершення.

4. **Закриття ресурсів**: Закрийте всі відкриті файлові дескриптори, мережеві сокети, з'єднання з базами даних та інші ресурси. Це допоможе уникнути витоків пам'яті та залишків.

5. **Збереження стану**: Якщо програма підтримує збереження стану, потрібно переконатися, що всі необхідні дані записані перед зупинкою.

6. **Логування та повідомлення**: Запишіть інформацію в лог про те, які операції було успішно завершено, і відправте потрібні повідомлення користувачам (якщо є).

### Приклад імплементації в Go:

```go
package main

import (
    "context"
    "log"
    "net/http"
    "os"
    "os/signal"
    "syscall"
    "time"
)

func main() {
    srv := &http.Server{Addr: ":8080"}

    // Горутин для запуску сервера
    go func() {
        if err := srv.ListenAndServe(); err != nil && err != http.ErrServerClosed {
            log.Fatalf("listen: %s\n", err)
        }
    }()
    log.Println("Server started on :8080")

    // Відстежуємо сигнали ОС
    quit := make(chan os.Signal, 1)
    signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

    <-quit // Чекаємо сигналу завершення
    log.Println("Shutdown signal received")

    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    if err := srv.Shutdown(ctx); err != nil {
        log.Fatal("Server forced to shutdown:", err)
    }

    log.Println("Server exiting")
}
```

У цьому прикладі сервер відстежує сигнали SIGINT та SIGTERM. При отриманні сигналу він перестає обробляти нові підключення, завершує поточні запити та очищує ресурси перед завершенням роботи.

| Back | Forward |
|---|---|
| [Що таке CLS і де варто його використовувати?](/ua/senior/architecture/what-is-cls-and-where-should-it-be-used.md)  | [Наведіть приклади імплементації GoF патернів у Node.js і фреймворках.](/ua/senior/architecture/provide-examples-of-implementing-gof-patterns-in-nodejs-and-frameworks.md) |